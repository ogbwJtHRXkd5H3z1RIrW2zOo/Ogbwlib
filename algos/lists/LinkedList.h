/** * @file    LinkedList.h * Liste chaînée générique basée sur l'allocation dynamique. Dans l'ensemble des fonctions, il faut bien se rappeller que la librairie travaille avec des pointeurs et ne recopie jamais les données. Cela implique : * - il faut bien que la donnée dont on fournit le pointeur soit aussi durable que la liste * - une modification sur élément de la liste le modifie partout * - il faut etre capable de savoir quand on applique la fonction free pour les allocations dynamiques * @warning Au moment de la compilation avec C30, il faut bien penser à estimer la taille du tas et la régler dans l'IDE. * @author ogbwJtHRXkd5H3z1RIrW2zOo*/#ifndef _LINKEDLIST_LIST_H_#define _LINKEDLIST_LIST_H_/** * @enum LinkedList_error * Enmeration des erreurs pouvant survenir lors de l'utilisation d'une LinkedList */typedef enum {    LINKEDLIST_OUT_OF_MEMORY,  /// La mémoire n'a pas permi la création d'un maillon    LINKEDLIST_OUT_OF_RANGE,   /// On a tenté d'accéder à un maillon d'indice supérieur à la taille de la liste    LINKEDLIST_SUCCESS         /// Pas d'erreur, tout c'est bien passé} LinkedList_error;typedef struct LinkedList_item_{	struct LinkedList_item_* next;	struct LinkedList_item_* prev;	void* data;} LinkedList_item;/** * @struct Linkedlist * Objet représentant une liste doublement chaînée. Théoriquement, il n'est pas utile d'accéder directement aux champs, les fonctions doivent suffir. */typedef struct {	LinkedList_item* first; /// premier élément de la liste (null si la liste est vide)	LinkedList_item* last;  /// dernier élément de la liste (null si la liste est vide)}* LinkedList;/** * Création d'un liste vide. Permet concretement d'initialiser les champs de la liste à null. * @return  une liste vide */LinkedList LinkedList_new();/** * Compte les éléments de la liste * @param list  liste dont on veut compter les éléments * @return  le nombre d'éléments de la liste */U16 LinkedList_size(volatile LinkedList list);/** * Check si la liste est vide. Plus rapide que LinkedList_size(list)==0 car on ne compte pas les éléments s'il y en a plusieurs. * @param list  liste à vérifier * @return  vrai ssi la liste est vide. */U8 LinkedList_isEmpty(volatile LinkedList list);/** * Inverse l'ordre de la liste. * @param list list à "retourner" */void LinkedList_reverse(LinkedList list);/** * Ajoute un élément en tête de liste. * @param list  liste à laquelle on ajoute un élément * @param data  pointeur vers l'élément à ajouter. * @return  OUT_OF_MEMORY ou SUCCESS selon la réussite de l'opération */LinkedList_error LinkedList_addFirst(volatile LinkedList list, void* data);/** * Ajoute un élément au milieu de la liste. * @param list  liste à laquelle on ajoute un élément * @param data  pointeur vers l'élément à ajouter. * @param num   numéro du message après insertion (la numérotation commence à 0) * @return  OUT_OF_RANGE, OUT_OF_MEMORY ou SUCCESS selon la réussite de l'opération */LinkedList_error LinkedList_addMiddle(volatile LinkedList list, void* data, U16 num);/** * Ajoute un élément à la fin de la liste. * @param list  liste à laquelle on ajoute un élément * @param data  pointeur vers l'élément à ajouter. * @return  OUT_OF_MEMORY ou SUCCESS selon la réussite de l'opération */LinkedList_error LinkedList_addLast(volatile LinkedList list, void* data);/** * Ajoute un élément dans une liste triée. * @param list  liste à laquelle on ajoute un élément * @param data  pointeur vers l'élément à ajouter. * @param isSmaller fonction d'ordre. isSmaller(a,b) doit renvoyer vrai ssi a<b. * @return  OUT_OF_MEMORY ou SUCCESS selon la réussite de l'opération */LinkedList_error LinkedList_addSorted(volatile LinkedList list, void* data, U8 (*isSmaller)(void*, void*));/** * Ajoute une série d'éléments en tête de liste. * @param dest  liste à laquelle on ajoute les éléments * @param src   liste d'éléments à ajouter * @return  OUT_OF_MEMORY ou SUCCESS selon la réussite de l'opération * @warning La métode fonctionne en ajoutant les éléments un par un (en partant de la fin). En cas de manque de mémoire, elle s'arrète, mais ne retire pas les éléments déjà insérés */LinkedList_error LinkedList_addAllFirst(LinkedList dest, LinkedList src);/** * Ajoute une série d'éléments en queue de liste. * @param dest  liste à laquelle on ajoute les éléments * @param src   liste d'éléments à ajouter * @return  OUT_OF_MEMORY ou SUCCESS selon la réussite de l'opération * @warning La métode fonctionne en ajoutant les éléments un par un. En cas de manque de mémoire, elle s'arrète, mais ne retire pas les éléments déjà insérés */LinkedList_error LinkedList_addAllLast(LinkedList dest, LinkedList src);/** * Ajoute une série d'éléments au milieu de la liste. * @param dest  liste à laquelle on ajoute les éléments * @param src   liste d'éléments à ajouter * @param n     rang auquel on insère les éléments (correspond après l'insertion au rang du premier élément de la partie insérée) * @return  OUT_OF_MEMORY ou SUCCESS selon la réussite de l'opération * @warning La métode fonctionne en ajoutant les éléments un par un (en partant de la fin). En cas de manque de mémoire, elle s'arrète, mais ne retire pas les éléments déjà insérés */LinkedList_error LinkedList_addAllMiddle(LinkedList dest, LinkedList src, int n);/** * Ajoute une série d'éléments dans un liste triée. * @param dest  liste à laquelle on ajoute les éléments * @param src   liste d'éléments à ajouter * @return  OUT_OF_MEMORY ou SUCCESS selon la réussite de l'opération * @warning La métode fonctionne en ajoutant les éléments un par un. En cas de manque de mémoire, elle s'arrète, mais ne retire pas les éléments déjà insérés */LinkedList_error LinkedList_addAllSorted(LinkedList dest, LinkedList src, U8 (*isSmaller)(void*, void*));/** * Fusionne deux listes. Diffère de LinkedList_addAllLast par le fait qu'avec merge, les listes d'origines ne sont plus utilisables. Par contre on n'utilise pas du tout de mémoire supplémentaire. * @param list1 liste qui restera en tête * @param list2 liste qui se trouvera à la fin * @return  liste fusionnée * @warning Les listes d'origines ne sont plus valides !! */LinkedList LinkedList_merge(LinkedList list1, LinkedList list2);/** * Fusionne deux listes triées. Au contraire de LinkedList_addAllSorted, les listes d'origines ne sont plus utilisables. Par contre on n'utilise pas du tout de mémoire supplémentaire. * @param list1 liste à fusionner * @param list2 liste à fusionner * @return  liste fusionnée * @warning Les listes d'origines ne sont plus valides !! */LinkedList LinkedList_mergeSorted(LinkedList list1, LinkedList list2, U8 (*isSmaller)(void*, void*));/** * Renvoie le premier élément de la liste. Ne le retire pas de la liste. * @param list  liste dont on veut lire le premier élément * @return  pointeur vers le premier élément, null si la liste est vide. */void* LinkedList_getFirst(volatile LinkedList list);/** * Renvoie un élément au milieu de la liste. Ne le retire pas de la liste. * @param list  liste dont on veut lire le premier élément * @param num   numéro de l'élément à renvoyer (numérotation commence à 0) * @return  pointeur vers l'élément, ou null si l'index est out of range */void* LinkedList_getMiddle(volatile LinkedList list, U16 num);/** * Renvoie le dernier élément de la liste. Ne le retire pas de la liste. * @param list  liste dont on veut lire le dernier élément * @return  pointeur vers le dernier élément, null si la liste est vide. */void* LinkedList_getLast(volatile LinkedList list);/** * Renvoie le premier élément de la liste correspondant à un filtre. Ne le retire pas de la liste. * @param list  liste dont on veut lire un élément * @param data  donnée de référence à laquelle on doit comparer les éléments de la liste * @param match   fonction filtre. match(element de la liste) doit renvoyer vrai pour tous l'élément à renvoyer. * @return  pointeur vers l'élément trouvé, null si aucun ne corresppond. */void* LinkedList_getFilter(volatile LinkedList list, U8 (*match)(void*));/** * Retire et renvoie le premier élément de la liste. * @param list  liste dont on veut retirer le premier élément * @return  pointeur vers le premier élément, null si la liste est vide. */void* LinkedList_removeFirst(volatile LinkedList list);/** * Retire et renvoie un élément au milieu de la liste. * @param list  liste dont on veut retirer le premier élément * @param num   numéro de l'élément à retirer (numérotation commence à 0) * @return  pointeur vers l'élément, ou null si l'index est out of range */void* LinkedList_removeMiddle(volatile LinkedList list, U16 num);/** * Retire et renvoie le dernier élément de la liste. * @param list  liste dont on veut retirer le dernier élément * @return  pointeur vers le dernier élément, null si la liste est vide. */void* LinkedList_removeLast(volatile LinkedList list);/** * Retire le premier élément de la liste dont le contenu est égal à la donnée. L'égalité est au sens du pointeur, pas du sens des données. * @param list  liste dont on veut retirer un élément * @param data  pointeur à retrouver dans la liste * @return  pointeur trouvé, null si on n'en a pas trouvé * @sa  Pour une égalité en terme de sens et non de pointeur, voir LinkedList_removeDataContent * @sa  Si on veut pouvoir retirer plusieurs éléments, voir LinkedList_removeAllPtr */void* LinkedList_removePtr(volatile LinkedList list, void* data);/** * Retire et renvoie le premier élément de la liste correspondant à un filtre. * @param list  liste dont on veut retirer un élément * @param data  donnée de référence à laquelle on doit comparer les éléments de la liste * @param match   fonction filtre. match(element de la liste) doit renvoyer vrai pour tous l'élément à retirer. * @return  pointeur vers l'élément trouvé, null si aucun ne corresppond. * @sa  Si on veut pouvoir retirer plusieurs éléments, voir LinkedList_removeIf */void* LinkedList_removeFilter(volatile LinkedList list, U8 (*match)(void*));/** * Retire tous les éléments de la liste. * @param list  liste à vider * @return  nombre d'éléments retirés de la liste * @warning la fonction ne gère pas la mémoire des éléments: si vous vouler libérer toute la mémoire, il faudra probablement faire des free sur ces éléments. * @sa Pour faire automatiquement les free, voir LinkedList_deleteAll */U16 LinkedList_removeAll(volatile LinkedList list);/** * Retire tous les éléments de la liste dont le contenu est égal à la donnée. L'égalité est au sens du pointeur, pas du sens des données. * @param list  liste dont on veut retirer les éléments * @param data  pointeur à retrouver dans la liste * @return  nombre d'éléments retirés */U16 LinkedList_removeAllPtr(volatile LinkedList list, void* data);/** * Retire tous les éléments de la liste correspondant à un filtre. * @param list  liste à vider * @param data  donnée de référence pour le filtre * @param match    fonction filtre. match(element de la liste) doit renvoyer vrai pour tous les éléments à retirer. * @return  nombre d'éléments retirés de la liste * @warning la fonction ne gère pas la mémoire des éléments: si vous vouler libérer toute la mémoire, il faudra probablement faire des free sur ces éléments. * @sa Pour faire automatiquement les free, voir LinkedList_deleteIf */U16 LinkedList_removeIf(volatile LinkedList list, U8 (*match)(void*));/** * Supprime le premier élément de la liste. Applique free à la donnée * @param list  liste dont on veut supprimer le premier élément * @sa  Si on ne veut pas libérer la mémoire de la donnée, voir LinkedList_removeFirst */void LinkedList_deleteFirst(volatile LinkedList list);/** * Supprime un élément de la liste. Applique free à la donnée. * @param list  liste dont on veut supprimer un élément * @sa  Si on ne veut pas libérer la mémoire de la donnée, voir LinkedList_removeMiddle * @warning Si l'élément n'existe pas, il n'y a pas de moyen de le savoir. */void LinkedList_deleteMiddle(volatile LinkedList list, U16 num);/** * Supprime le dernier élément de la liste. Applique free à la donnée * @param list  liste dont on veut supprimer le dernier élément * @sa  Si on ne veut pas libérer la mémoire de la donnée, voir LinkedList_removeLast */void LinkedList_deleteLast(volatile LinkedList list);/** * Supprime le premier élément de la liste dont le contenu est égal à la donnée. L'égalité est au sens du pointeur, pas du sens des données. Applique free à la donnée. * @param list  liste dont on veut supprimer un élément * @param data  pointeur à retrouver dans la liste * @sa  Pour une égalité en terme de sens et non de pointeur, voir LinkedList_deleteDataContent * @sa  Si on veut pouvoir retirer plusieurs éléments, voir LinkedList_deleteAllPtr */void LinkedList_deletePtr(volatile LinkedList list, void* data);/** * Supprime le premier élément de la liste correspondant à un filtre. Applique free à l'élément trouvé * @param list  liste dont on veut supprimer un élément * @param data  donnée de référence à laquelle on doit comparer les éléments de la liste * @param match   fonction filtre. match(element de la liste) doit renvoyer vrai pour l'élément à supprimer. * @sa  Si on veut pouvoir retirer plusieurs éléments, voir LinkedList_deleteIf */void LinkedList_deleteFilter(volatile LinkedList list, U8 (*match)(void*));/** * Supprime tous les éléments de la liste. Applique free à chaqun. * @param list  liste à vider * @return nombre d'éléments supprimés * @warning Si un élément est en double, free lui sera appliqué deux fois, cette fonction est donc interdite. Utiliser LinkedList_deleteAllWithDuplicates à la place */U16 LinkedList_deleteAll(volatile LinkedList list);/** * Supprime tous les éléments de la liste. Applique free à chaqun. * @param list  liste à vider * @return nombre d'éléments supprimés * @sa Si la liste ne comporte aucun élément en double, LinkedList_deleteAll sera plus rapide */U16 LinkedList_deleteAllWithDuplicates(volatile LinkedList list);/** * Supprime toutes les occurences d'un pointeur de la liste. Applique free au pointeur. * @param list  liste dont on veut supprimer les éléments * @param data  élément à supprimer * @return le nombre d'éléments supprimés */U16 LinkedList_deleteAllPtr(volatile LinkedList list, void* data);/** * Supprime toutes les occurences d'un pointeur correspondant à un filtre. Applique free à chaqun. * @param list  liste dont on supprime les éléments * @param data  donnée de référenceà laquelle on compare les éléments de la liste * @param match fonction filtre. match(element de la liste) doit renvoyer vrai pour tous les éléments à supprimer. * @return  le nombre d'éléments supprimés */U16 LinkedList_deleteIf(volatile LinkedList list, U8 (*match)(void*));/** * Execute une fonction à tous les éléments de la liste. * @param list  liste dont les éléments se verront appliquer la fonction * @param todo  fonction à appliquer : todo(1° élément de la liste), todo(2° élément de la liste)... * @return   */void LinkedList_executeAll(volatile LinkedList list, void (*todo)(void*));/** * Execute une fonction à tous les éléments de la , en partant de la fin. * @param list  liste dont les éléments se verront appliquer la fonction * @param todo  fonction à appliquer : todo(n° élément de la liste), todo(n-1° élément de la liste)... * @return */void LinkedList_reverseExecuteAll(volatile LinkedList list, void (*todo)(void*));/** * Execute une fonction à tous les éléments de la liste correspondant à un filtre. * @param list  liste à filtrer * @param match fonction filtre. match(element) renvoie vrai ssi on veut executer todo(element) * @param todo  fonction à appliquer aux éléments filtrés * @return */U16 LinkedList_executeIf(volatile LinkedList list, U8 (*match)(void*), void (*todo)(void*));/** * Execute une fonction à tous les éléments de la liste correspondant à un filtre, en partant de la fin. * @param list  liste à filtrer * @param match fonction filtre. match(element) renvoie vrai ssi on veut executer todo(element) * @param todo  fonction à appliquer aux éléments filtrés * @return */U16 LinkedList_reverseExecuteIf(volatile LinkedList list, U8 (*match)(void*), void (*todo)(void*));#endif//